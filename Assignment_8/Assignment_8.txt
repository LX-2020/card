//Assignment_8 Seven Segment Displays on Consoles by Lexin Ma 3/4/20
//BooleanFunc class
public class BooleanFunc implements Cloneable
{
   public static int MAX_TABLE_FOR_CLASS = 65536; 
   public static int DEFAULT_TABLE_SIZE = 16;
   
   private int tableSize;
   private boolean[] truthTable;
   private boolean evalReturnIfError = false;
   private boolean state;

   BooleanFunc()
   {
      tableSize = DEFAULT_TABLE_SIZE;
      truthTable = new boolean[tableSize]; 
   }
   
   BooleanFunc(int tableSize)
   {
      this.tableSize = tableSize;
      truthTable = new boolean[tableSize]; 
         
   }
   
   BooleanFunc(int tableSize, boolean evalReturnIfError)
   {
      this.evalReturnIfError = evalReturnIfError;
      this.tableSize = tableSize;
      truthTable = new boolean[tableSize];  
   }
  
   public boolean setTruthTableUsingTrue(int[] inputsThatProduceTrue) 
   {
      //if there are more false booleans, set all array members to false
      for(int i = 0; i < tableSize; i++)
      {
         truthTable[i] = false;
      }
      //set true according to passed in index array
      for(int i = 0; i  < inputsThatProduceTrue.length; i++)
      {   
         if(inputsThatProduceTrue[i] >= 0 && inputsThatProduceTrue[i] < tableSize)
         {
            truthTable[inputsThatProduceTrue[i]] = true;
         }
      }
      
      if(inputsThatProduceTrue.length <= tableSize)
         return true; 
      else return false;
   }

   public boolean setTruthTableUsingFalse(int[] inputsThatProduceFalse) 
   {
      for(int i = 0; i < tableSize; i++)
      {
         truthTable[i] = true;
      }
      
      for(int i = 0; i < inputsThatProduceFalse.length; i++)
      { 
         if(inputsThatProduceFalse[i] >= 0 && inputsThatProduceFalse[i] < tableSize)
         truthTable[inputsThatProduceFalse[i]] = false; 
      }
      
      if(inputsThatProduceFalse.length <= tableSize)
         return true; 
      else return false;
   }
   
   public boolean eval(int input) 
   {
      if(input >= 0 && input < tableSize - 1)
         state = truthTable[input];
      else state = evalReturnIfError;
     
      return state;
   }

   public boolean getState()
   {
      return state;
   }
   
   public Object clone() throws CloneNotSupportedException
   {
      BooleanFunc newObject = (BooleanFunc)super.clone();
      
      newObject.tableSize = this.tableSize;
      for(int i=0;i<this.tableSize;i++)
         newObject.truthTable[i] = this.truthTable[i];
      
      return newObject;
   }
}

//base class
public class MultiSegmentLogic implements Cloneable
{
   protected int numSegs;
   protected BooleanFunc[] segs;
      
   MultiSegmentLogic()
   {
      numSegs = 0;
      setNumSegs(numSegs);
   }
   
   MultiSegmentLogic(int numSegs)
   {
      this.numSegs = numSegs;
      setNumSegs(numSegs);
   }
   
   public boolean setNumSegs(int numSegs) 
   {
      if(numSegs >= 0)
      {
         this.numSegs = numSegs;
         segs = new BooleanFunc[numSegs];
      }
      return true;
   }
   
   public boolean setSegment(int segNum, BooleanFunc funcForThisSeg) 
   {
      if(segNum >= 0 && segNum <= numSegs - 1)
      {
         try
         {
            segs[segNum] = (BooleanFunc)funcForThisSeg.clone();
            return true;
            
         } catch (CloneNotSupportedException e)
         {
            System.out.println("** Clone Unsuccessful **");
         }
         
      }
      return false;
   }
   
   public void eval(int input)
   {
      for(int i = 0; i < numSegs; i++)
      {
         segs[i].eval(input);
      }
   }
   
   public Object clone() throws CloneNotSupportedException
   {
      MultiSegmentLogic newObject = (MultiSegmentLogic)super.clone();
      
      newObject.numSegs = this.numSegs;
      for(int i=0;i<this.numSegs;i++)
      {
         newObject.segs[i] = this.segs[i];
      }
      
      return newObject;
   }   
}

//derived class
public class SevenSegmentLogic extends MultiSegmentLogic
{
   SevenSegmentLogic()
   {
     super(7);
     loadFunc();
   }
   
   public boolean getValOfSeg(int seg) 
   {
      if(seg >= 0 && seg < 7)
         return segs[seg].getState();
      return false;              
   }
   
   //helper method to set boolean functions for segments
   private void loadFunc()
   {
     
      int a[] = {1,4,11,13};
      int b[] = {5,6,11,12,14,15};
      int c[] = {2,12,14,15};
      int d[] = {1,4,7,9,10,15};
      int e[] = {1,3,4,5,7,9};
      int f[] = {1,2,3,13};
      int g[] = {0,1,7,12};
      int Ffunc[][] = {a, b, c, d, e, f, g};
      
      for(int i = 0; i < numSegs; i++)
      {
         BooleanFunc bFunc = new BooleanFunc();
         bFunc.setTruthTableUsingFalse(Ffunc[i]);
         setSegment(i, bFunc);
      }
   }
}

//SevenSegmentImage class for printing out according to boolean segments 
class SevenSegmentImage implements Cloneable
{
   public static final int MIN_HEIGHT = 5;
   public static final int MIN_WIDTH = 5;
   public static final int MAX_HEIGHT = 65;
   public static final int MAX_WIDTH = 41;
   public static final String DRAW_CHAR = "*";
   public static final String BLANK_CHAR = " ";

   private boolean[][] data;
   private int topRow, midRow, bottomRow, leftCol, rightCol;

   public SevenSegmentImage()
   {
      setSize(MIN_WIDTH, MIN_HEIGHT);
      topRow = midRow = bottomRow = MIN_WIDTH;
      leftCol = rightCol = MIN_HEIGHT;
   }

   public SevenSegmentImage(int width, int height)
   {
      setSize(width, height);
      topRow = midRow = bottomRow = width;
      leftCol = rightCol = height;
   }

   public void clearImage()
   {
      for(int row = 0; row < leftCol; row++)
      {
         for(int col = 0; col < topRow; col++)
         {
            data[row][col] = false;
            System.out.print(BLANK_CHAR);
         }
         System.out.println("");
      }
   }
   
   private void allocateCleanArray(int width, int height)
   {
      topRow = midRow = bottomRow = width;
      leftCol = rightCol = height;
      data = new boolean[leftCol][topRow];
      clearImage();
   }
   
   public boolean setSize(int width, int height)
   {
      if(validateSize(width,height))
      {
         allocateCleanArray(width,height);        
         return true;
      }
      else return false;   
   }

   public boolean turnOnCellsForSegment(char segment)
   {
       char seg = Character.toLowerCase(segment);
       switch(seg)
       {
          case 'a':
             drawHorizontal(0, topRow);              
             break;
             
          case 'b':
             drawVertical(topRow-1,0,rightCol/2);
             break;
             
          case 'c':
             drawVertical(topRow-1,(rightCol/2)+1,rightCol);
             break;
             
          case 'd':
             drawHorizontal(leftCol-1, bottomRow);              
             break;
             
          case 'e':
             drawVertical(0,(leftCol/2)+1,leftCol);
             break;
             
          case 'f':
             drawVertical(0,0,leftCol/2);
             break;
             
          case 'g':
             drawHorizontal(leftCol/2, midRow); 
             break;
             
          default:
             System.out.println("invalid segment");
             break;  
       }
      return true;       
   }

   public void display()
   {
      for(int row = 0; row < leftCol; row++)
      {
         for(int col = 0; col < topRow; col++)
         {
            if(!data[row][col])           
               System.out.print(BLANK_CHAR);
            
            else 
               System.out.print(DRAW_CHAR);           
         }
         System.out.println("");
      }
   }

   // deep copy required
   public Object clone() throws CloneNotSupportedException
   {
      SevenSegmentImage newObject = (SevenSegmentImage)super.clone();
      
      for(int i=0;i<this.leftCol;i++)
      {
         for(int k=0;k<this.topRow;k++)
         {
            newObject.data[i][k] = this.data[i][k];
         }
      }     
      return newObject; 
   }

   private boolean validateSize(int width, int height)
   {
      if((width > MIN_WIDTH) && (width <MAX_WIDTH) && ((width % 2)!= 0) &&
      (height > MIN_HEIGHT && height < MAX_HEIGHT) && ((height % 2)!= 0) )
         return true;
      else return false;
   }   

   // helpers
   void drawHorizontal(int startRow, int row)
   {
      for(int col = 0; col < row; col++)
      {
         data[startRow][col] = true;
      }           
   }

   void drawVertical(int col, int startRow, int stopRow)
   {
      for(int row = startRow; row < stopRow ; row++)
      {
         data[row][col] = true;
      }
   }
}

//display console image according to segmentlogic
class SevenSegmentDisplay  implements Cloneable
{
   private SevenSegmentImage theImage;
   private SevenSegmentLogic theDisplay;

   public SevenSegmentDisplay()
   {
      theImage = new SevenSegmentImage();
      theDisplay = new SevenSegmentLogic();
   }
   
   public SevenSegmentDisplay( int width, int height )
   {
      theImage = new SevenSegmentImage(width, height);
      theDisplay = new SevenSegmentLogic();
   }
   
   public boolean setSize( int width, int height )
   {
      if(theImage.setSize(width, height))
         return true;
      else return false;
   }
   
   public void loadConsoleImage()
   {
      theImage.clearImage();
      for(int i = 0; i <7; i++)
      {
         if(theDisplay.getValOfSeg(i))
         {
            char seg = (char)(i+65);
            theImage.turnOnCellsForSegment(seg);
         }
      }
   }
   
   public void consoleDisplay()
   {
      theImage.display();
   }
   
   public void eval( int input )
   {
      theDisplay.eval(input);
   }

   public Object clone() throws CloneNotSupportedException
   {
      SevenSegmentDisplay newObject = (SevenSegmentDisplay)super.clone();
      return newObject;
   }
}

//main class
public class Foothill
{
   public static void main(String[] args)
   {
      /*
      SevenSegmentImage ssi = new SevenSegmentImage();

      System.out.println(
         "Testing SevenSegmentImage ===================================");

      ssi.setSize( 7, 9 );
      ssi.turnOnCellsForSegment( 'a' );
      ssi.display();
      ssi.turnOnCellsForSegment( 'b' );
      ssi.display();
      ssi.turnOnCellsForSegment( 'c' );
      ssi.display();
      ssi.turnOnCellsForSegment( 'd' );
      ssi.display();

      ssi.clearImage();
      ssi.turnOnCellsForSegment( 'e' );
      ssi.display();
      ssi.turnOnCellsForSegment( 'f' );
      ssi.display();
      ssi.turnOnCellsForSegment( 'g' );
      ssi.display();

      ssi.clearImage();
      ssi.turnOnCellsForSegment( 'x' );
      ssi.display();
      ssi.turnOnCellsForSegment( '3' );
      ssi.display();
      */
      
      SevenSegmentDisplay  my7SegForCon = new SevenSegmentDisplay( 15, 13 );
      int j;
      
      System.out.println(
         "Testing SevenSegmentDisplay ===================================");

      my7SegForCon.setSize( 7, 9 );
      for ( j = 0; j < 16; j++ )
      {
         my7SegForCon.eval( j );
         my7SegForCon.loadConsoleImage();
         my7SegForCon.consoleDisplay();
      }

      for ( j = 5; j < 21; j += 4)
      {
         my7SegForCon.setSize( j, 2*j + 1 );
         my7SegForCon.eval( 5 );
         my7SegForCon.loadConsoleImage();
         my7SegForCon.consoleDisplay();
      }
   }  
}

/*--------------------console run--------------------------
               
               
               
               
               
               
               
               
               
               
               
               
               
Testing SevenSegmentDisplay ===================================
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
*******
*     *
*     *
*     *
       
*     *
*     *
*     *
*******
       
       
       
       
       
       
       
       
       
      *
      *
      *
      *
       
      *
      *
      *
      *
       
       
       
       
       
       
       
       
       
*******
      *
      *
      *
*******
*      
*      
*      
*******
       
       
       
       
       
       
       
       
       
*******
      *
      *
      *
*******
      *
      *
      *
*******
       
       
       
       
       
       
       
       
       
*     *
*     *
*     *
*     *
*******
      *
      *
      *
      *
       
       
       
       
       
       
       
       
       
*******
*      
*      
*      
*******
      *
      *
      *
*******
       
       
       
       
       
       
       
       
       
*******
*      
*      
*      
*******
*     *
*     *
*     *
*******
       
       
       
       
       
       
       
       
       
*******
*     *
*     *
*     *
       
      *
      *
      *
      *
       
       
       
       
       
       
       
       
       
*******
*     *
*     *
*     *
*******
*     *
*     *
*     *
*******
       
       
       
       
       
       
       
       
       
*******
*     *
*     *
*     *
*******
      *
      *
      *
      *
       
       
       
       
       
       
       
       
       
*******
*     *
*     *
*     *
*******
*     *
*     *
*     *
*     *
       
       
       
       
       
       
       
       
       
*      
*      
*      
*      
*******
*     *
*     *
*     *
*******
       
       
       
       
       
       
       
       
       
*******
*      
*      
*      
       
*      
*      
*      
*******
       
       
       
       
       
       
       
       
       
      *
      *
      *
      *
*******
*     *
*     *
*     *
*******
       
       
       
       
       
       
       
       
       
*******
*      
*      
*      
*******
*      
*      
*      
*******
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
*******
*      
*      
*      
*******
      *
      *
      *
*******
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
*********
*        
*        
*        
*        
*        
*        
*        
*        
*********
        *
        *
        *
        *
        *
        *
        *
        *
*********
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
*************
*            
*            
*            
*            
*            
*            
*            
*            
*            
*            
*            
*            
*************
            *
            *
            *
            *
            *
            *
            *
            *
            *
            *
            *
            *
*************
                 
                 
                 
*/                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
*****************
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*                
*****************
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
                *
*****************

