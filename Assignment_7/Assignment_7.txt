//Assignment_7 Deep Memory Seven Segment Displays by Lexin Ma 2/26/20
//boolean function class, set and get boolean array
public class BooleanFunc implements Cloneable
{
   public static int MAX_TABLE_FOR_CLASS = 65536; 
   public static int DEFAULT_TABLE_SIZE = 16;
   
   private int tableSize;
   private boolean[] truthTable;
   private boolean evalReturnIfError = false;
   private boolean state;

   BooleanFunc()
   {
      tableSize = DEFAULT_TABLE_SIZE;
      truthTable = new boolean[tableSize]; 
   }
   
   BooleanFunc(int tableSize)
   {
      this.tableSize = tableSize;
      truthTable = new boolean[tableSize]; 
         
   }
   
   BooleanFunc(int tableSize, boolean evalReturnIfError)
   {
      this.evalReturnIfError = evalReturnIfError;
      this.tableSize = tableSize;
      truthTable = new boolean[tableSize];  
   }
  
   public boolean setTruthTableUsingTrue(int[] inputsThatProduceTrue) 
   {
      //if there are more false booleans, set all array members to false
      for(int i = 0; i < tableSize; i++)
      {
         truthTable[i] = false;
      }
      //set true according to passed in index array
      for(int i = 0; i  < inputsThatProduceTrue.length; i++)
      {   
         if(inputsThatProduceTrue[i] >= 0 && inputsThatProduceTrue[i] < tableSize)
         {
            truthTable[inputsThatProduceTrue[i]] = true;
         }
      }
      
      if(inputsThatProduceTrue.length <= tableSize)
         return true; 
      else return false;
   }

   public boolean setTruthTableUsingFalse( int[] inputsThatProduceFalse ) 
   {
      for(int i = 0; i < tableSize; i++)
      {
         truthTable[i] = true;
      }
      
      for(int i = 0; i < inputsThatProduceFalse.length; i++)
      { 
         if(inputsThatProduceFalse[i] >= 0 && inputsThatProduceFalse[i] < tableSize)
         truthTable[inputsThatProduceFalse[i]] = false; 
      }
      
      if(inputsThatProduceFalse.length <= tableSize)
         return true; 
      else return false;
   }
   
   public boolean eval(int input) 
   {
      if(input >= 0 && input < tableSize - 1)
         state = truthTable[input];
      else state = evalReturnIfError;
     
      return state;
   }

   public boolean getState()
   {
      return state;
   }
   
   public Object clone() throws CloneNotSupportedException
   {
      BooleanFunc newObject = (BooleanFunc)super.clone();
      
      newObject.tableSize = this.tableSize;
      for(int i=0;i<this.tableSize;i++)
         newObject.truthTable[i] = this.truthTable[i];
      
      return newObject;
   }
   

}

//base class
public class MultiSegmentLogic implements Cloneable
{
   protected int numSegs;
   protected BooleanFunc[] segs;
   
   
   MultiSegmentLogic()
   {
      numSegs = 0;
      segs = new BooleanFunc[numSegs];
   }
   
   MultiSegmentLogic(int numSegs)
   {
      this.numSegs = numSegs;
      segs = new BooleanFunc[numSegs];
   }
   
   public boolean setNumSegs( int numSegs ) 
   {
      if(numSegs >= 0)
      {
         this.numSegs = numSegs;
         segs = new BooleanFunc[numSegs];
      }
      return true;
   }
   
   public boolean setSegment( int segNum, BooleanFunc funcForThisSeg) 
   {
      if(segNum >= 0 && segNum <= numSegs - 1)
      {
         try
         {
            segs[segNum] = (BooleanFunc)funcForThisSeg.clone();
            return true;
            
         } catch (CloneNotSupportedException e)
         {
            System.out.println("** Clone Unsuccessful **");
         }
         
      }
      return false;
   }
   
   public void eval(int input)
   {
      for(int i = 0; i < numSegs; i++)
      {
         segs[i].eval(input);
      }
   }
   
   public Object clone() throws CloneNotSupportedException
   {
      MultiSegmentLogic newObject = (MultiSegmentLogic)super.clone();
      
      newObject.numSegs = this.numSegs;
      for(int i=0;i<this.numSegs;i++)
      {
         newObject.segs[i] = this.segs[i];
      }
      
      return newObject;
   }
   
   
}

//derived class
public class SevenSegmentLogic extends MultiSegmentLogic
{
   SevenSegmentLogic()
   {
     super(7);
     loadFunc();
   }
   
   public boolean getValOfSeg(int seg) 
   {
      if(seg >= 0 && seg < 7)
         return segs[seg].getState();
      return false;              
   }
   
   //helper method to set boolean functions for segments
   private void loadFunc()
   {
     
      int a[] = {1,4,11,13};
      int b[] = {5,6,11,12,14,15};
      int c[] = {2,12,14,15};
      int d[] = {1,4,7,9,10,15};
      int e[] = {1,3,4,5,7,9};
      int f[] = {1,2,3,13};
      int g[] = {0,1,7};
      int Ffunc[][] = {a, b, c, d, e, f, g};
      
      for(int i = 0; i < numSegs; i++)
      {
         BooleanFunc bFunc = new BooleanFunc();
         bFunc.setTruthTableUsingFalse(Ffunc[i]);
         setSegment(i, bFunc);
      }
   }
}

//main class
public class Foothill
{
   public static void main(String[] args)
   {
      /*//Phase 1
      BooleanFunc segA, segB, segC;

      int  inputX, k;

      int evenFunc[] = { 0, 2, 4, 6, 8, 10, 12, 14 };
      int greater9Func[] = { 10, 11, 12, 13, 14, 15 };;
      int greater3Func[] = { 0, 1, 2, 3 };
      
      segA = new BooleanFunc();
      segB = new BooleanFunc( 13 );
      segC = new BooleanFunc( 100, true );

      segA.setTruthTableUsingTrue( evenFunc );
      segB.setTruthTableUsingTrue( greater9Func );
      segC.setTruthTableUsingFalse( greater3Func );

      System.out.println( "before eval()" );
      System.out.println(
         "\n  A(x) = "
         + segA.getState()
         + "\n  B(x) = "
         + segB.getState()
         + "\n  C(x) = "
         + segC.getState()
         + "\n" );
      System.out.println( "looping with eval()" );

      for ( inputX = 0; inputX < 10; inputX++ )
      {
         segA.eval( inputX );
         segB.eval( inputX );
         segC.eval( inputX );
         System.out.println(
            "Input: " + inputX
            + "\n  A(x) = "
            + segA.getState()
            + ";  B(x) = "
            + segB.getState()
            + ";  C(x) = "
            + segC.getState()
            + "\n" );
      }
   }*/
      
      
      //Phase 2
      int inputX, k;
      SevenSegmentLogic my7Seg, myCopy;
      
      my7Seg = new SevenSegmentLogic();
      
      //test clone method;
      try
      {
         myCopy = (SevenSegmentLogic) my7Seg.clone();
      }
      catch  ( CloneNotSupportedException e )
      {
         System.out.println("** Clone Unsuccessful **");
         myCopy = new SevenSegmentLogic();
      }
      
      //display seven segments logic
      for ( inputX = 0; inputX < 16; inputX++ )
      {
         myCopy.eval( inputX );
         System.out.print("\n|" + "number" + inputX + "|");
         for ( k = 0; k < 7; k++ )
            System.out.print( myCopy.getValOfSeg( k ) + " ; ");
         System.out.println();
      } 
      
   } 
}

/*-------------console run test------------
Phase 1:
before eval()

  A(x) = false
  B(x) = false
  C(x) = false

looping with eval()
Input: 0
  A(x) = true;  B(x) = false;  C(x) = false

Input: 1
  A(x) = false;  B(x) = false;  C(x) = false

Input: 2
  A(x) = true;  B(x) = false;  C(x) = false

Input: 3
  A(x) = false;  B(x) = false;  C(x) = false

Input: 4
  A(x) = true;  B(x) = false;  C(x) = true

Input: 5
  A(x) = false;  B(x) = false;  C(x) = true

Input: 6
  A(x) = true;  B(x) = false;  C(x) = true

Input: 7
  A(x) = false;  B(x) = false;  C(x) = true

Input: 8
  A(x) = true;  B(x) = false;  C(x) = true

Input: 9
  A(x) = false;  B(x) = false;  C(x) = true

//phase2:
|number0|true ; true ; true ; true ; true ; true ; false ; 

|number1|false ; true ; true ; false ; false ; false ; false ; 

|number2|true ; true ; false ; true ; true ; false ; true ; 

|number3|true ; true ; true ; true ; false ; false ; true ; 

|number4|false ; true ; true ; false ; false ; true ; true ; 

|number5|true ; false ; true ; true ; false ; true ; true ; 

|number6|true ; false ; true ; true ; true ; true ; true ; 

|number7|true ; true ; true ; false ; false ; true ; false ; 

|number8|true ; true ; true ; true ; true ; true ; true ; 

|number9|true ; true ; true ; false ; false ; true ; true ; 

|number10|true ; true ; true ; false ; true ; true ; true ; 

|number11|false ; false ; true ; true ; true ; true ; true ; 

|number12|true ; false ; false ; true ; true ; true ; true ; 

|number13|false ; true ; true ; true ; true ; false ; true ; 

|number14|true ; false ; false ; true ; true ; true ; true ; 

|number15|false ; false ; false ; false ; false ; false ; false ; 
