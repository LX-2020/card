//Assignment_4 Encryption Keys and Inheritance by Lexin Ma 2/05/20
//------------option A-----------------------------
//Base class 
public class InternetUser
{
   public final static int MAX_NAME_LENGTH = 50;
   public final static int MIN_NAME_LENGTH = 2;
   public final static int MAX_IP_LENGTH = 15;
   public final static int MIN_IP_LENGTH = 7;
   public final static String DEFAULT_NAME = "undefined";
   public final static String DEFAULT_IP = "0.0.0.0";
   
   private String name;
   private String ip;
   
   //two constructors
   InternetUser()
   {
      name = DEFAULT_NAME;
      ip = DEFAULT_IP;
   }
   
   InternetUser(String name, String ip)
   {
      setName(name);
      setIp(ip);
   }
   
   //mutators
   public void setName(String name)
   {
      if( validName(name) )
         this.name = name;
      else this.name = DEFAULT_NAME;
   }
   
   public void setIp(String ip)
   {
      if( validIp(ip) )
         this.ip = ip;
      else this.ip = DEFAULT_IP;
   }
   
   //accessors
   public String getName()
   {
      return name;
   }
   
   public String getIp()
   {
      return ip;
   }
   
   public String toString()
   {  
      return  "Name: " + name + "\nIp Address: " + ip + "\n\n";      
   }
   
   //validation helpers
   private boolean validName(String name)
   {
      if ( name.length() < MIN_NAME_LENGTH 
            || name.length() > MAX_NAME_LENGTH )         
         return false;
      
      return true;
   }
   
   private boolean validIp(String ip)
   {
      if ( ip.length() < MIN_IP_LENGTH 
            || ip.length() > MAX_IP_LENGTH )         
         return false;
      
      return true;
   }

}

//Derived class
public class Communicator extends InternetUser
{
   public final static int ERROR_FLAG_NUM = 0;
   private final static int MAX_PQ = (int
         )Math.sqrt(Long.MAX_VALUE);
   
   private long firstPrime;
   private long secondPrime;
   private long n, phi, e, d;
   private IntPair publicKey;
   private IntPair privateKey;
   
   //constructors
   Communicator()
   {
      super();
      firstPrime = ERROR_FLAG_NUM;
      secondPrime = ERROR_FLAG_NUM;
   }
   
   Communicator(long p, long q)
   {
      super();
      if( !setPrime(p, q) )
      {
         firstPrime = ERROR_FLAG_NUM;
         secondPrime = ERROR_FLAG_NUM;
      }
         
   }
   
   Communicator(String name,String ip)
   {
      super(name,ip);
      firstPrime = ERROR_FLAG_NUM;
      secondPrime = ERROR_FLAG_NUM;
   }
   
   Communicator(String name,String ip, long p, long q)
   {
      super(name,ip);
      
      if( !setPrime(p, q) )
      {
         firstPrime = ERROR_FLAG_NUM;
         secondPrime = ERROR_FLAG_NUM;
      }       
   }
   
   //mutators
   public boolean setPrime(long p, long q)
   {
      if( !EncryptionSupport.isPrime(p) || !EncryptionSupport.isPrime(q)
            || p > MAX_PQ || q > MAX_PQ || p == q )         
         return false;
       
      firstPrime = p;
      secondPrime = q;
      computeBothEncrKeys(p,q);
      return true;         
   }
   
   //accessors
   public IntPair getPublicKey()
   { 
      return publicKey;     
   }
   
   public IntPair getPrivateKey()
   {
      return privateKey;
   }
   
   public String toString()
   {
      return super.toString() + "(p, q)  n, phi, e, d: " + "(" + firstPrime + 
            "," + secondPrime + ") " + n + "," + phi + "," + e + "," + d +
            "\npublic key" + publicKey 
              + "\nprivate key" + privateKey + "\n\n";
   }
   
   private boolean computeBothEncrKeys(long p,long q)
   {
      n = p * q;
      phi = (p - 1) * (q - 1);
      do
      {
         e = EncryptionSupport.getSmallRandomPrime();          
      }while(e > phi && phi % e == 0);
       
      d = EncryptionSupport.inverseModN(e, n);
      
      publicKey = new IntPair(e, n);
      privateKey = new IntPair(d, n); 
      
      return true;      
   }
   
}

//Helper class
import java.lang.*;
import java.util.*;

// IntPair allows public, no filtering; classes that use it will protect it
class IntPair
{
   public long firstInt;
   public long secondInt;

   // constructors
   IntPair() { firstInt = secondInt = 0; }
   IntPair(long frst, long scnd) { firstInt = frst;  secondInt = scnd; }
   
   public String toString()
   {  
      return "(" + firstInt + ", " + secondInt + ")";
   }
};

// EncryptionSupport contains only static methods for client use 
// method names should be fairly descriptive except inverseMonN(), which
// you can take as a black-box (see description of assignment)
class EncryptionSupport
{
   static private Random randObject = new Random(System.currentTimeMillis());
   
   public static boolean isPrime(long x)
   {
      long k, loopLim;

      if (x < 2)
         return false;
      if (x < 4)
         return true;
      if (x % 2 == 0 || x % 3 == 0)
         return false;

      // now use the fact the all primes of form 6k +/- 1
      loopLim = (long)Math.sqrt(x);
      for (k = 5; k <= loopLim; k += 6)
      {
         if (x % k == 0 || x % (k + 2) == 0)
            return false;
      }
      return true;
   }
   
   public static long inverseModN(long a, long n)
   {
      // uses extended euclidean algorithm giving as + nt = gcd(n, a), 
      // with gcd(n, a) = 1,  and s, t discovered.  s = 1/a, and t ignored

      long s, t, r, sPrev, tPrev, rPrev, temp, q, inverse;

      // special key encryption conditions;  we will pick some prime e >= 3 for a
      if (a < 3 || a >= n || !isPrime(a))
         return 0;  // error
      // we are now guaranteed 3 <= a < n and gcd(a, n) = 1;
      // initialize working variables
      s = 0;         t = 1;         r = n;
      sPrev = 1;    tPrev = 0;    rPrev = a;

      while (r != 0)
      {
         q = rPrev / r;

         temp = r;
         r = rPrev - q * r;
         rPrev = temp;

         temp = s;
         s = sPrev - q * s;
         sPrev = temp;

         temp = t;
         t = tPrev - q * t;
         tPrev = temp;
      }

      inverse = sPrev % n;
      if (inverse < 0)
         inverse += n;
      return inverse;
   }
   
   public static long getSmallRandomPrime()
   {
      int index;
      long lowPrimes[] =
      {
               19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
               71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,
               127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
               179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
               233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
               283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
               353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
               419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
               467, 479, 487, 491, 499, 503, 509, 521, 523, 541
      };
      long arraySize = lowPrimes.length;

      // pick prime in the above array bet 0 and arraySize - 1
      index = (int)( randObject.nextDouble() * arraySize );

      return lowPrimes[index]; 
   }
   
   public static long getMedSizedRandomPrime()
   {
      int index;
      long medPrimes[] =
      {
            541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
            613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677,
            683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,
            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853,
            857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,
            941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019,
            1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087,
            1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153,
            1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,
      };
      long arraySize = medPrimes.length;

      // pick prime in the above array bet 0 and arraySize - 1
      index = (int)(randObject.nextDouble() * arraySize );

      return medPrimes[index]; 
   }
}

//main class
import java.util.Scanner;

public class Foothill
{
   public static void main (String[] args)
   {
      //phase 1 Base class:
      InternetUser user1, user2, user3, user4;
      user1 = new InternetUser();
      user2 = new InternetUser("John", "3.2.5.6");
      user3 = new InternetUser("", "1.3.7"); //invalid name
      user4 = new InternetUser("Mary", "1.4.2"); //invalid ip
      
      System.out.println(user1.toString() + user2 + user3 + user4);
      
      //test mutator
      user1.setIp("3.1.6.4");
      user1.setName("Ben");
      user3.setName("Lily");
      user3.setIp("2.5.1.3");
      user4.setIp("1.4.2.5");
            
      System.out.println("After set correct name and Ip address: \n"
            + user1 + user2 + user3 + user4);
     
      //test accessor
      System.out.println("Get the second user's name:\n" + user2.getName());
            
      //phase 2 Derived class:
      long p, q; 
      String strUserIn;
      Communicator num1, num2, num3, num4;
      num1 = new Communicator();
      System.out.println("\n" + num1);
      
      Scanner inputStream = new Scanner(System.in);      
      System.out.println("\nEnter two prime numbers: ");
      strUserIn = inputStream.nextLine();
      p = Long.parseLong(strUserIn);       
      strUserIn = inputStream.nextLine();
      q = Long.parseLong(strUserIn);
      
      num2 = new Communicator(p,q);
      System.out.println(num2);
      
      num3 = new Communicator( "John","2.1.4.2" );
      System.out.println(num3);
            
      System.out.println("\nEnter two prime numbers: ");
      strUserIn = inputStream.nextLine();
      p = Long.parseLong(strUserIn);
      strUserIn = inputStream.nextLine();
      q = Long.parseLong(strUserIn);
      num4 = new Communicator( "Mary","1.4.2.6",p,q );
      System.out.println(num4);
      
      //test Derived class mutator and accessor
      if(num1.getPublicKey() == null || num1.getPrivateKey() == null)
      System.out.println("\nEnter two prime numbers: " );
      strUserIn = inputStream.nextLine();
      p = Long.parseLong(strUserIn);
      strUserIn = inputStream.nextLine();
      q = Long.parseLong(strUserIn);
      
      num1.setPrime(p, q);
      System.out.println(num1);
      
    }
}

 /*----------------- console output-------------
Base class test
  
Name: undefined
Ip Address: 0.0.0.0

Name: John
Ip Address: 3.2.5.6

Name: undefined
Ip Address: 0.0.0.0

Name: Mary
Ip Address: 0.0.0.0


After set correct name and Ip address: 
Name: Ben
Ip Address: 3.1.6.4

Name: John
Ip Address: 3.2.5.6

Name: Lily
Ip Address: 2.5.1.3

Name: Mary
Ip Address: 1.4.2.5


Get the second user's name:
John

//Derived class test
Name: undefined
Ip Address: 0.0.0.0

(p, q)  n, phi, e, d: (0,0) 0,0,0,0
public keynull
private keynull



Enter two prime numbers: 
3789
37
Name: undefined
Ip Address: 0.0.0.0

(p, q)  n, phi, e, d: (0,0) 0,0,0,0
public keynull
private keynull


Name: John
Ip Address: 2.1.4.2

(p, q)  n, phi, e, d: (0,0) 0,0,0,0
public keynull
private keynull



Enter two prime numbers: 
37
79
Name: Mary
Ip Address: 1.4.2.6

(p, q)  n, phi, e, d: (37,79) 2923,2808,461,875
public key(461, 2923)
private key(875, 2923)



Enter two prime numbers: 
67
67
Name: undefined
Ip Address: 0.0.0.0

(p, q)  n, phi, e, d: (0,0) 0,0,0,0
public keynull
private keynull

 */

//--------------option B-------------
//Base class1
public class Stack
{
   // pointer to first node in stack
   private StackNode top;
   
   // constructor
   public Stack()
   {
      top = null;
   }
   
   public void push(StackNode newNode)
   {   
      if (newNode == null) 
         return;   
      newNode.next = top;
      top = newNode;
   }  
   
   public StackNode pop()
   {
      StackNode temp;
     
      temp = top;
      if (top != null)
      {
         top = top.next; 
         temp.next = null; 
      }
      return temp;      
   }

   // console display
    public String toString()
   {
      StackNode p;
      String ret="";
      
      // Display all the nodes in the stack
      for( p = top; p != null; p = p.next )
         ret += p.toString();
      
      return ret;
   }
}      
//Base class2
public class StackNode
{
   protected StackNode next;
    
   // constructor
   public StackNode()
   {
      next = null;
   }
   
   // console display
    public String toString()
   {
      return "";
   }
}      
//Derived class1
class IuStack extends Stack
{
   public static final InternetUser STACK_EMPTY = null;

   //push a node into the stack
   public void pushIu(InternetUser x)
   {
      if (x == STACK_EMPTY)
         return;    
      IuNode Iu = new IuNode(x);
     
      super.push(Iu);
   }

   //pop a node off the stack
   public InternetUser popIu()
   {
      IuNode Iu = (IuNode)pop();
      if (Iu == null)
         return STACK_EMPTY;
      else
         return Iu.getItu();
    }
    
    public String toString()
   {
      return super.toString();
   }
}      
//Derived class2
class IuNode extends StackNode
{
   // additional data for subclass
   InternetUser Iu;
   
   // constructor
   public IuNode(InternetUser x)
   {
      super();  
      Iu = new InternetUser();
      Iu = x;
   }
   
   // accessor
   public InternetUser getItu()
   {
      return Iu;
   }
 
   public String toString()
   {
      return Iu.toString();
   }
}
//option B main class
public class Foothill
{
   public static void main (String[] args)
   {
      IuStack iustk = new IuStack();
      InternetUser iu, iu1, iu2, iu3, iu4;
      iu1 = new InternetUser();
      iu2 = new InternetUser("John", "3.2.5.6");
      iu3 = new InternetUser("Mary", "1.4.2.5");
      iu4 = new InternetUser("Ben", "1.4.2.7");

      iustk.pushIu(iu1);
      iustk.pushIu(iu2);
      iustk.pushIu(iu3);
      iustk.pushIu(iu4);
      
      System.out.print("The Internet user stack: " + "\n" + iustk);
      
      for (int k = 0; k < 5; k++)
         if ( (iu = iustk.popIu()) != IuStack.STACK_EMPTY)
            System.out.print("#" + k + "Internet user\n" + iu);    
         else
            System.out.print("(empty stack) ");
      System.out.println();
    }
}
 

/*----------console output----------
The Internet user stack: 
Name: Ben
Ip Address: 1.4.2.7

Name: Mary
Ip Address: 1.4.2.5

Name: John
Ip Address: 3.2.5.6

Name: undefined
Ip Address: 0.0.0.0

#0Internet user
Name: Ben
Ip Address: 1.4.2.7

#1Internet user
Name: Mary
Ip Address: 1.4.2.5

#2Internet user
Name: John
Ip Address: 3.2.5.6

#3Internet user
Name: undefined
Ip Address: 0.0.0.0

(empty stack) 

*/      
      
      
      
      
      



